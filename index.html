// app.js (FULL WORKING + OCR)
// - Loads data/recipes_en.json or data/recipes_zh.json
// - Inventory table in fixed material order
// - Target tree (Hero -> Theme -> Parts), collapsed
// - Theme checkbox selects/deselects all parts; parts update theme indeterminate
// - Compute: reserve required from inventory; use surplus-only to plan exchanges
// - Two modes: 3first vs 6first
// IMPORTANT RULE UPDATE:
//   - 3→1: requires 3 SAME materials (same name), not just same rarity
//   - 6→1: can use ANY 6 materials of same rarity (mixed allowed), output specified

///////////////////////////////
// 0) Material bilingual order
///////////////////////////////
const MATERIAL_ORDER_RAW = [
  "怪物精华Monster Essence",
  "怪物毛皮Monster Fur",
  "怪物爪子Monster Claws",
  "惨爪龙的硬肌Odogaron Sinew",
  "惨爪龙的重牙Odogaron Hardfang",
  "惨爪龙的鳞Odogaron Scale",
  "雷狼龙的高电毛Zinogre Electrofur",
  "雷狼龙的雷电壳Zinogre Deathly Shocker",
  "雷狼龙的重壳Zinogre Cortex",
  "火龙的坚壳Rathalos Carapace",
  "火龙的翅膀Rathalos Wings",
  "火龙的尾巴Rathalos Tail",
  "麒麟的雷角Kirin Thunderhorn",
  "麒麟的皮Kirin Hide",
  "麒麟的鬃毛Kirin Mane",
  "太古大骨Ancient Bone",
  "冠突龙的甲壳Kestodon Shell",
  "野猪的头Bullfango Head",
  "大桶Large Barrel",
  "火药粉Gunpowder",
  "铁矿石Iron Ore",
  "惨爪龙的厚鳞Odogaron Shard",
  "惨爪龙的天鳞Odogaron Mantle",
  "雷狼龙的刚角Zinogre Hardhorn",
  "雷狼龙的天玉Zinogre Skymerald",
  "火龙的红玉Rathalos Ruby",
  "火龙的逆鳞Rathalos Plate",
  "麒麟的苍角Kirin Azure Horn",
  "古龙的大宝玉Large Elder Dragon Gem",
  "龙玉Wyvern Gem",
  "扭曲狂骨Warped Bone",
  "灾祸之布Sinister Cloth",
  "鬼硝化伞菇Devils Blight",
  "艾露猫票券Palico Voucher",
  "噗嗤猪票券Poogie Voucher",
  "棱彩颜料Prismatic Pigment",
];

const SPLIT_RE = /^(.*?)([A-Za-z].*)$/;
const MATERIALS = MATERIAL_ORDER_RAW.map(s => {
  const m = s.match(SPLIT_RE);
  if (!m) return { zh: s.trim(), en: s.trim(), combo: s.trim() };
  const zh = m[1].trim();
  const en = m[2].trim();
  return { zh, en, combo: `${zh} ${en}`.trim() };
});

const MATERIAL_ORDER_EN = MATERIALS.map(x => x.en);
const EN_TO_ZH = Object.fromEntries(MATERIALS.map(x => [x.en, x.zh]));
const ZH_TO_EN = Object.fromEntries(MATERIALS.map(x => [x.zh, x.en]));
const COMBO_TO_EN = Object.fromEntries(MATERIALS.map(x => [x.combo, x.en]));

///////////////////////////////
// 1) Rarity
///////////////////////////////
const RARITY_LV = { "Common": 1, "Uncommon": 2, "Rare": 3, "Super Rare": 4 };
const LV_RARITY = { 1: "Common", 2: "Uncommon", 3: "Rare", 4: "Super Rare" };

const RARITY_ALIAS_TO_EN = {
  "普通": "Common",
  "常见": "Common",
  "罕见": "Uncommon",
  "不常见": "Uncommon",
  "稀有": "Rare",
  "超级珍稀": "Super Rare",
  "超级稀有": "Super Rare",
  "超稀有": "Super Rare",
};

function normRarity(x) {
  let s = String(x ?? "").trim();
  s = s.replace(/\.\d+$/, "");
  if (RARITY_LV[s]) return s;
  if (RARITY_ALIAS_TO_EN[s]) return RARITY_ALIAS_TO_EN[s];
  if (s.toLowerCase() === "superrare") return "Super Rare";
  return s;
}

function normMaterialToEN(raw) {
  const s0 = String(raw ?? "").replace(/\r/g, " ").replace(/\n/g, " ").trim();
  if (!s0) return s0;

  if (ZH_TO_EN[s0]) return ZH_TO_EN[s0];
  if (COMBO_TO_EN[s0]) return COMBO_TO_EN[s0];

  const m = s0.match(SPLIT_RE);
  if (m) {
    const zh = m[1].trim();
    const en = m[2].trim();
    if (EN_TO_ZH[en]) return en;
    if (ZH_TO_EN[zh]) return ZH_TO_EN[zh];
    return en;
  }

  if (EN_TO_ZH[s0]) return s0;
  return s0;
}

function displayMaterial(lang, enKey) {
  return lang === "zh" ? (EN_TO_ZH[enKey] ?? enKey) : enKey;
}

///////////////////////////////
// 2) UI text
///////////////////////////////
const UI = {
  en: {
    title: "MH Planner",
    language: "Language:",
    strategy: "Strategy:",
    inv: "Inventory",
    invHint: "Enter how many materials you own.",
    tar: "Targets",
    tarHint: "Select the parts/sets you still need. (Collapsed by default)",
    compute: "Compute",
    copy: "Copy Output",
    out: "Output",
    statusReady: (n) => `Ready. Loaded ${n} recipe rows.`,
    noSelection: "Please select at least one target.",
    fetchFail: "Failed to load data. Ensure JSON exists and run via http (GitHub Pages or python -m http.server).",
    mode3: "Low clicks (prefer 3→1; if insufficient then 6→1)",
    mode6: "Rarity-first (prefer 6→1; if needed then 3→1)",
    reportMode: (m) => `[Mode] ${m}`,
    selected: (n) => `You selected ${n} targets:`,
    set: (name) => `- Set: ${name}`,
    part: (setName, part) => `- Part: ${setName} / ${part}`,
    sec1: "## 1) Total required (for checking)",
    sec2: "## 2) Reserved from inventory (do NOT exchange these)",
    sec3: "## 3) Remaining deficits (need exchange/upgrade)",
    sec4: "## 4) Surplus available for exchange (ONLY use these)",
    sec5: "## 5) Exchange steps (copy/paste)",
    sec6: "## 6) Final remaining deficits",
    none: "- (none)",
    ok: "✅ Conclusion: Using surplus-only exchanges, you can complete the selected targets.",
    notOk: "⚠️ Conclusion: Using surplus-only exchanges, you still cannot fill the deficits (usually highest rarity not enough).",
    step3: (i, rar, matName, target, times) =>
      `${i}. 3→1 (${rar}) SAME material: consume ${matName} ×${3 * times}\n   Output select: ${target} ×${times}`,
    step6: (i, r1, r2, cons, breakdown, target, times) =>
      `${i}. 6→1 upgrade (${r1}→${r2}): consume ${cons} (${breakdown})\n   Output select: ${target} ×${times}`,
  },
  zh: {
    title: "MH Planner",
    language: "语言：",
    strategy: "策略：",
    inv: "库存",
    invHint: "输入你拥有的材料数量。",
    tar: "目标",
    tarHint: "勾选你还没做完的套装/部件。（默认折叠）",
    compute: "开始计算",
    copy: "复制输出",
    out: "输出",
    statusReady: (n) => `就绪。已加载 ${n} 条配方。`,
    noSelection: "请先勾选至少一个目标。",
    fetchFail: "加载失败：请确认 JSON 文件存在，并使用 http 方式运行（GitHub Pages 或 python -m http.server）。",
    mode3: "少操作（优先 3→1；不够再 6→1）",
    mode6: "稀有度优先（尽量 6→1；无奈才 3→1）",
    reportMode: (m) => `【模式】${m}`,
    selected: (n) => `你选择了 ${n} 个目标：`,
    set: (name) => `- 整套：${name}`,
    part: (setName, part) => `- 部件：${setName} / ${part}`,
    sec1: "## 1) 目标总需求（核对用）",
    sec2: "## 2) 直接合成清单（已预留，别拿去换）",
    sec3: "## 3) 仍缺材料（需要兑换/升阶补）",
    sec4: "## 4) 可用于兑换的多余材料（只动这里）",
    sec5: "## 5) 兑换步骤（可直接照抄）",
    sec6: "## 6) 最终仍缺",
    none: "- （无）",
    ok: "✅ 结论：只用多余材料兑换，你可以补齐所选目标。",
    notOk: "⚠️ 结论：只用多余材料兑换，你仍无法补齐缺口（通常最高稀有度不够）。",
    step3: (i, rar, matName, target, times) =>
      `${i}. 3→1（${rar}）必须同种材料：消耗 ${matName} ×${3 * times}\n   产出请选择：${target} ×${times}`,
    step6: (i, r1, r2, cons, breakdown, target, times) =>
      `${i}. 6→1 升阶（${r1}→${r2}）：消耗 ${cons}（${breakdown}）\n   产出请选择：${target} ×${times}`,
  }
};
function t(lang){ return UI[lang] ?? UI.en; }

///////////////////////////////
// 3) Global state
///////////////////////////////
let LANG = "en";
let MODE = "3first";
let RECIPES = [];
let MATERIAL_SET = new Map(); // enKey -> {rarity, rarity_lv, order}
let HERO_TREE = [];
let INVENTORY = {}; // enKey -> int
let CURRENT_MATERIAL_ORDER = []; // ordered list currently in inventory table

///////////////////////////////
// 4) DOM helpers
///////////////////////////////
function qs(id){ return document.getElementById(id); }

///////////////////////////////
// 5) Theme checkbox linkage
///////////////////////////////
function setThemeState(themeDiv, checked) {
  const partCbs = themeDiv.querySelectorAll('input[type="checkbox"][data-role="part"]');
  partCbs.forEach(cb => { cb.checked = checked; });
}

function updateThemeCheckbox(themeDiv) {
  const themeCb = themeDiv.querySelector('input[type="checkbox"][data-role="theme"]');
  const partCbs = [...themeDiv.querySelectorAll('input[type="checkbox"][data-role="part"]')];
  if (!themeCb) return;

  const total = partCbs.length;
  const checkedCount = partCbs.filter(cb => cb.checked).length;

  if (checkedCount === 0) {
    themeCb.checked = false;
    themeCb.indeterminate = false;
  } else if (checkedCount === total) {
    themeCb.checked = true;
    themeCb.indeterminate = false;
  } else {
    themeCb.checked = false;
    themeCb.indeterminate = true;
  }
}

///////////////////////////////
// 6) Data load
///////////////////////////////
async function loadData(lang) {
  const path = (lang === "zh") ? "data/recipes_zh.json" : "data/recipes_en.json";
  const res = await fetch(path);
  if (!res.ok) throw new Error(`fetch ${path} failed (${res.status})`);
  const raw = await res.json();

  const recipes = [];
  for (const r of raw) {
    const setName = String(r.set_name ?? r.category ?? "").trim();
    const part = String(r.part ?? r.item ?? "").trim();
    const materialEN = normMaterialToEN(r.material);
    const rarityEN = normRarity(r.rarity);
    const amount = Number(r.amount ?? 0) | 0;
    if (!setName || !part || !materialEN || !amount) continue;
    recipes.push({ setName, part, material: materialEN, rarity: rarityEN, amount });
  }
  return recipes;
}

function buildMaterialSet(recipes) {
  const rarityByMat = new Map();
  for (const row of recipes) {
    if (!rarityByMat.has(row.material)) rarityByMat.set(row.material, row.rarity);
  }

  const orderMap = new Map(MATERIAL_ORDER_EN.map((m, i) => [m, i]));
  const unknowns = [];
  for (const row of recipes) {
    if (!orderMap.has(row.material) && !unknowns.includes(row.material)) unknowns.push(row.material);
  }
  for (let i = 0; i < unknowns.length; i++) orderMap.set(unknowns[i], MATERIAL_ORDER_EN.length + i);

  const list = [];
  for (const [mat, idx] of orderMap.entries()) {
    if (!rarityByMat.has(mat)) continue;
    const rar = rarityByMat.get(mat);
    const lv = RARITY_LV[rar] ?? 1;
    list.push({ mat, rar, lv, idx });
  }
  list.sort((a,b)=>a.idx-b.idx);

  const mset = new Map();
  for (const x of list) mset.set(x.mat, { rarity: x.rar, rarity_lv: x.lv, order: x.idx });
  return { mset, ordered: list.map(x=>x.mat) };
}

function splitSetName(setName) {
  const s = String(setName).trim();
  const parts = s.split(" ", 2);
  if (parts.length === 1) return { hero: parts[0], theme: "Base" };
  return { hero: parts[0], theme: parts.slice(1).join(" ").trim() || "Base" };
}

function buildTree(recipes) {
  const heroOrder = new Map();
  const themeOrder = new Map();
  const partOrder = new Map();
  let heroIdx = 0, themeIdx = 0, partIdx = 0;

  const rows = [];
  for (const r of recipes) {
    const { hero, theme } = splitSetName(r.setName);
    const hk = hero;
    const tk = `${hero}||${theme}`;
    const pk = `${r.setName}||${r.part}`;
    if (!heroOrder.has(hk)) heroOrder.set(hk, heroIdx++);
    if (!themeOrder.has(tk)) themeOrder.set(tk, themeIdx++);
    if (!partOrder.has(pk)) partOrder.set(pk, partIdx++);
    rows.push({ hero, theme, setName: r.setName, part: r.part, ho: heroOrder.get(hk), to: themeOrder.get(tk), po: partOrder.get(pk) });
  }

  const seen = new Set();
  const unique = [];
  for (const x of rows) {
    const k = `${x.setName}||${x.part}`;
    if (seen.has(k)) continue;
    seen.add(k);
    unique.push(x);
  }
  unique.sort((a,b)=> (a.ho-b.ho) || (a.to-b.to) || (a.po-b.po));

  const heroes = [];
  const heroMap = new Map();
  for (const x of unique) {
    if (!heroMap.has(x.hero)) {
      const node = { hero: x.hero, themes: [] };
      heroMap.set(x.hero, node);
      heroes.push(node);
    }
    const hnode = heroMap.get(x.hero);
    let tnode = hnode.themes.find(t => t.theme === x.theme && t.setName === x.setName);
    if (!tnode) {
      tnode = { theme: x.theme, setName: x.setName, parts: [] };
      hnode.themes.push(tnode);
    }
    tnode.parts.push({ part: x.part, setName: x.setName });
  }
  return heroes;
}

///////////////////////////////
// 7) Render
///////////////////////////////
function renderStaticTexts() {
  const U = t(LANG);
  document.title = U.title;

  qs("title").textContent = U.title;
  qs("langLabel").textContent = U.language;
  qs("modeLabel").textContent = U.strategy;
  qs("invTitle").textContent = U.inv;
  qs("invHint").textContent = U.invHint;
  qs("tarTitle").textContent = U.tar;
  qs("tarHint").textContent = U.tarHint;
  qs("computeBtn").textContent = U.compute;
  qs("copyBtn").textContent = U.copy;
  qs("outTitle").textContent = U.out;

  const modeSel = qs("mode");
  if (modeSel && modeSel.options?.length >= 2) {
    modeSel.options[0].text = U.mode3;
    modeSel.options[1].text = U.mode6;
  }
}

function renderInventory(materialOrder) {
  CURRENT_MATERIAL_ORDER = materialOrder.slice();

  const body = qs("invBody");
  body.innerHTML = "";

  for (const enKey of materialOrder) {
    const info = MATERIAL_SET.get(enKey);
    if (!info) continue;

    const tr = document.createElement("tr");

    const tdM = document.createElement("td");
    tdM.textContent = displayMaterial(LANG, enKey);
    tdM.dataset.key = enKey;

    const tdR = document.createElement("td");
    tdR.textContent = info.rarity;

    const tdO = document.createElement("td");
    const inp = document.createElement("input");
    inp.type = "number";
    inp.min = "0";
    inp.value = String(INVENTORY[enKey] ?? 0);
    inp.addEventListener("input", () => {
      INVENTORY[enKey] = Math.max(0, parseInt(inp.value || "0", 10));
    });
    tdO.appendChild(inp);

    tr.appendChild(tdM);
    tr.appendChild(tdR);
    tr.appendChild(tdO);
    body.appendChild(tr);
  }
}

function renderTree(tree) {
  const root = qs("tree");
  root.innerHTML = "";

  for (const h of tree) {
    const detHero = document.createElement("details");
    detHero.open = false;

    const sum = document.createElement("summary");
    sum.textContent = h.hero;
    detHero.appendChild(sum);

    for (const th of h.themes) {
      const divTheme = document.createElement("div");
      divTheme.className = "theme";

      const head = document.createElement("label");
      head.className = "theme-head";

      const cbTheme = document.createElement("input");
      cbTheme.type = "checkbox";
      cbTheme.dataset.role = "theme";
      cbTheme.dataset.token = JSON.stringify(["SET", th.setName]);

      const lab = document.createElement("span");
      lab.textContent = th.theme;

      head.appendChild(cbTheme);
      head.appendChild(lab);
      divTheme.appendChild(head);

      const divParts = document.createElement("div");
      divParts.className = "parts";

      for (const p of th.parts) {
        const row = document.createElement("label");
        row.className = "row";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.dataset.role = "part";
        cb.dataset.token = JSON.stringify(["PART", p.setName, p.part]);

        const span = document.createElement("span");
        span.textContent = p.part;

        row.appendChild(cb);
        row.appendChild(span);
        divParts.appendChild(row);
      }

      divTheme.appendChild(divParts);
      updateThemeCheckbox(divTheme);
      detHero.appendChild(divTheme);
    }

    root.appendChild(detHero);
  }
}

function getSelectedTokens() {
  const checks = qs("tree").querySelectorAll('input[type="checkbox"]');
  const tokens = [];
  const seen = new Set();
  for (const cb of checks) {
    if (!cb.checked) continue;
    const tok = JSON.parse(cb.dataset.token);
    const key = JSON.stringify(tok);
    if (seen.has(key)) continue;
    seen.add(key);
    tokens.push(tok);
  }
  return tokens;
}

///////////////////////////////
// 8) Demand/reserve
///////////////////////////////
function computeDemand(tokens) {
  const setWanted = new Set(tokens.filter(t=>t[0]==="SET").map(t=>t[1]));
  const partWanted = new Set(tokens.filter(t=>t[0]==="PART").map(t=>`${t[1]}||${t[2]}`));

  const need = new Map();
  const rarity = new Map();

  for (const r of RECIPES) {
    const isSet = setWanted.has(r.setName);
    const isPart = partWanted.has(`${r.setName}||${r.part}`);
    if (!isSet && !isPart) continue;

    need.set(r.material, (need.get(r.material) ?? 0) + r.amount);
    if (!rarity.has(r.material)) rarity.set(r.material, r.rarity);
  }

  const ordered = [];
  for (const enKey of MATERIAL_ORDER_EN) {
    if (!need.has(enKey)) continue;
    ordered.push({ material: enKey, need: need.get(enKey), rarity: rarity.get(enKey) });
  }
  for (const [m, v] of need.entries()) {
    if (MATERIAL_ORDER_EN.includes(m)) continue;
    ordered.push({ material: m, need: v, rarity: rarity.get(m) });
  }
  return ordered;
}

function reserveAndSurplus(demandList, inv) {
  const useDirect = {};
  const leftover = {};
  const deficit = {};

  const needMap = {};
  for (const d of demandList) needMap[d.material] = d.need;

  const allMats = [...new Set([...MATERIAL_ORDER_EN, ...Object.keys(needMap)])];

  for (const m of allMats) {
    const have = inv[m] ?? 0;
    const need = needMap[m] ?? 0;
    const use = Math.min(have, need);
    if (use > 0) useDirect[m] = use;

    const left = have - use;
    const def = need - use;
    if (left > 0) leftover[m] = left;
    if (def > 0) deficit[m] = def;
  }
  return { useDirect, leftover, deficit };
}

///////////////////////////////
// 9) Exchange planning (UPDATED RULES)
///////////////////////////////
function materialsByRarity(materialOrder) {
  const by = {1:[],2:[],3:[],4:[]};
  for (const m of materialOrder) {
    const info = MATERIAL_SET.get(m);
    if (!info) continue;
    by[info.rarity_lv].push(m);
  }
  return by;
}

// 6->1 consumes ANY 6 of same rarity (mixed allowed)
function takeMixedFromSurplus(surplus, candidatesInOrder, needQty) {
  const taken = new Map();
  let remaining = needQty;

  for (let i = candidatesInOrder.length - 1; i >= 0; i--) {
    const m = candidatesInOrder[i];
    if (remaining <= 0) break;
    const have = surplus[m] ?? 0;
    if (have <= 0) continue;

    const use = Math.min(have, remaining);
    surplus[m] = have - use;
    taken.set(m, (taken.get(m) ?? 0) + use);
    remaining -= use;
  }

  if (remaining > 0) {
    // undo
    for (const [m, q] of taken.entries()) surplus[m] = (surplus[m] ?? 0) + q;
    return null;
  }

  const out = [];
  for (const m of candidatesInOrder) if (taken.has(m)) out.push([m, taken.get(m)]);
  return out;
}

// 3->1 requires SAME material name: consume that material in multiples of 3
function takeSameTriples(surplus, materialName, times) {
  const need = 3 * times;
  const have = surplus[materialName] ?? 0;
  if (have < need) return false;
  surplus[materialName] = have - need;
  return true;
}

function planExchanges(mode, deficit, leftover, materialOrder) {
  const by = materialsByRarity(materialOrder);

  const matToLv = {};
  for (const m of materialOrder) matToLv[m] = MATERIAL_SET.get(m)?.rarity_lv ?? 1;

  const surplus = {};
  for (const m of materialOrder) surplus[m] = leftover[m] ?? 0;

  const rem = {...deficit};
  const ops = [];

  const surplusCount = (lv) => by[lv].reduce((s,m)=>s+(surplus[m]??0),0);

  const deficitsInOrderForLv = (lv) => {
    const out = [];
    for (const m of materialOrder) {
      if ((rem[m] ?? 0) > 0 && matToLv[m] === lv) out.push([m, rem[m]]);
    }
    for (const m of Object.keys(rem)) {
      if (materialOrder.includes(m)) continue;
      if ((rem[m] ?? 0) > 0 && matToLv[m] === lv) out.push([m, rem[m]]);
    }
    return out;
  };

  const do3_same = (lv, target, times) => {
    if (times <= 0) return true;
    // must use SAME material as target
    if (!takeSameTriples(surplus, target, times)) return false;
    ops.push({ kind:"3to1_same", from:lv, to:lv, target, times, consumed: [[target, 3*times]] });
    rem[target] = Math.max(0, (rem[target] ?? 0) - times);
    if (rem[target] === 0) delete rem[target];
    return true;
  };

  const do6_mixed = (fromLv, target, times) => {
    if (times <= 0) return true;
    const consumed = takeMixedFromSurplus(surplus, by[fromLv], 6 * times);
    if (!consumed) return false;
    ops.push({ kind:"6to1_mixed", from:fromLv, to:fromLv+1, target, times, consumed });
    rem[target] = Math.max(0, (rem[target] ?? 0) - times);
    if (rem[target] === 0) delete rem[target];
    return true;
  };

  // Fill deficits from high rarity down
  for (const lv of [4,3,2,1]) {
    if (lv === 4) {
      // Super Rare can only come from Rare via 6->1
      for (const [target, need] of deficitsInOrderForLv(4)) {
        const possible = Math.floor(surplusCount(3) / 6);
        const take = Math.min(need, possible);
        if (take > 0) do6_mixed(3, target, take);
      }
      continue;
    }

    for (let [target, need] of deficitsInOrderForLv(lv)) {
      if (need <= 0) continue;

      if (mode === "3first") {
        // 3->1 same-material first (only possible if surplus[target] has enough multiples of 3)
        const possible3 = Math.floor((surplus[target] ?? 0) / 3);
        const take3 = Math.min(need, possible3);
        if (take3 > 0) {
          do3_same(lv, target, take3);
          need = rem[target] ?? 0;
        }
        // then upgrade from lower via 6->1 mixed
        if (need > 0 && lv > 1) {
          const possible6 = Math.floor(surplusCount(lv - 1) / 6);
          const take6 = Math.min(need, possible6);
          if (take6 > 0) do6_mixed(lv - 1, target, take6);
        }
      } else {
        // 6->1 mixed first
        if (lv > 1) {
          const possible6 = Math.floor(surplusCount(lv - 1) / 6);
          const take6 = Math.min(need, possible6);
          if (take6 > 0) {
            do6_mixed(lv - 1, target, take6);
            need = rem[target] ?? 0;
          }
        }
        // then 3->1 same-material
        if (need > 0) {
          const possible3 = Math.floor((surplus[target] ?? 0) / 3);
          const take3 = Math.min(need, possible3);
          if (take3 > 0) do3_same(lv, target, take3);
        }
      }
    }
  }

  const remDef = {};
  for (const [k,v] of Object.entries(rem)) if (v > 0) remDef[k] = v;
  return { ops, remDef };
}

///////////////////////////////
// 10) Report
///////////////////////////////
function formatReport(tokens, demandList, matsOrder, useDirect, deficitBefore, leftover, ops, deficitAfter) {
  const U = t(LANG);
  const mname = (enKey)=> displayMaterial(LANG, enKey);

  const listInOrder = (obj) => {
    const out = [];
    for (const m of matsOrder) if ((obj[m] ?? 0) > 0) out.push([m, obj[m]]);
    for (const m of Object.keys(obj)) {
      if (matsOrder.includes(m)) continue;
      if ((obj[m] ?? 0) > 0) out.push([m, obj[m]]);
    }
    return out;
  };

  const lines = [];
  const modeLabel = (MODE === "3first") ? U.mode3 : U.mode6;

  lines.push(U.reportMode(modeLabel));
  lines.push("");
  lines.push(U.selected(tokens.length));
  for (const tok of tokens) {
    if (tok[0] === "SET") lines.push(U.set(tok[1]));
    else lines.push(U.part(tok[1], tok[2]));
  }
  lines.push("");

  lines.push(U.sec1);
  if (!demandList.length) lines.push(U.none);
  else demandList.forEach(d => lines.push(`- ${mname(d.material)} ×${d.need} (${d.rarity})`));
  lines.push("");

  lines.push(U.sec2);
  const resv = listInOrder(useDirect);
  if (!resv.length) lines.push(U.none);
  else resv.forEach(([m,v])=> lines.push(`- ${mname(m)} ×${v} ✅`));
  lines.push("");

  lines.push(U.sec3);
  const deb = listInOrder(deficitBefore);
  if (!deb.length) lines.push(U.none + " ✅");
  else deb.forEach(([m,v])=> lines.push(`- ${mname(m)} ×${v}`));
  lines.push("");

  lines.push(U.sec4);
  const sup = listInOrder(leftover);
  if (!sup.length) lines.push(U.none);
  else sup.forEach(([m,v])=> lines.push(`- ${mname(m)} ×${v}`));
  lines.push("");

  lines.push(U.sec5);
  if (!ops.length) lines.push(U.none);
  else {
    let i = 1;
    for (const op of ops) {
      if (op.kind === "3to1_same") {
        lines.push(U.step3(i, LV_RARITY[op.from], mname(op.target), mname(op.target), op.times));
      } else {
        const breakdown = op.consumed.length
          ? op.consumed.map(([m,q])=>`${mname(m)}×${q}`).join(" + ")
          : "-";
        lines.push(U.step6(i, LV_RARITY[op.from], LV_RARITY[op.to], 6*op.times, breakdown, mname(op.target), op.times));
      }
      i++;
    }
  }
  lines.push("");

  lines.push(U.sec6);
  const daf = listInOrder(deficitAfter);
  if (!daf.length) {
    lines.push(U.none + " ✅");
    lines.push("");
    lines.push(U.ok);
  } else {
    daf.forEach(([m,v])=> lines.push(`- ${mname(m)} ×${v}`));
    lines.push("");
    lines.push(U.notOk);
  }

  return lines.join("\n");
}

///////////////////////////////
// 11) Compute
///////////////////////////////
function compute() {
  const U = t(LANG);
  const tokens = getSelectedTokens();
  if (!tokens.length) {
    qs("output").textContent = U.noSelection;
    return;
  }

  const demandList = computeDemand(tokens);
  const inv = { ...INVENTORY };
  const { useDirect, leftover, deficit } = reserveAndSurplus(demandList, inv);

  const matsOrder = CURRENT_MATERIAL_ORDER.length ? CURRENT_MATERIAL_ORDER : MATERIAL_ORDER_EN.slice();

  const { ops, remDef } = planExchanges(MODE, deficit, leftover, matsOrder);
  const report = formatReport(tokens, demandList, matsOrder, useDirect, deficit, leftover, ops, remDef);
  qs("output").textContent = report;
}

///////////////////////////////
// 12) Reload all
///////////////////////////////
async function reloadAll() {
  renderStaticTexts();
  qs("status").textContent = "Loading…";

  try {
    RECIPES = await loadData(LANG);
  } catch (e) {
    qs("status").textContent = t(LANG).fetchFail;
    qs("output").textContent = String(e);
    return;
  }

  const { mset, ordered } = buildMaterialSet(RECIPES);
  MATERIAL_SET = mset;

  for (const m of ordered) if (INVENTORY[m] == null) INVENTORY[m] = 0;

  HERO_TREE = buildTree(RECIPES);
  renderInventory(ordered);
  renderTree(HERO_TREE);

  qs("status").textContent = t(LANG).statusReady(RECIPES.length);
  qs("output").textContent = LANG === "zh"
    ? "已就绪：你可以上传全屏截图，用 OCR 自动填库存。"
    : "Ready: you can upload a full screenshot and OCR-fill inventory.";
}

///////////////////////////////
// 13) OCR MODULE
///////////////////////////////
function initOcrUI() {
  const shotFile = document.getElementById("shotFile");
  const autoRoiBtn = document.getElementById("autoRoiBtn");
  const manualRoiBtn = document.getElementById("manualRoiBtn");
  const ocrBtn = document.getElementById("ocrBtn");
  const ocrCanvas = document.getElementById("ocrCanvas");
  const statusEl = document.getElementById("status");

  // If HTML doesn't include OCR controls, silently skip.
  if (!shotFile || !autoRoiBtn || !manualRoiBtn || !ocrBtn || !ocrCanvas) return;

  if (typeof Tesseract === "undefined") {
    statusEl.textContent = "Tesseract not loaded (add CDN script before app.js).";
    return;
  }

  // Fixed 36 slots in your order.
  const TOTAL_SLOTS = 36;
  const MATERIAL_ORDER_EN_FIXED = [
    "Monster Essence",
    "Monster Fur",
    "Monster Claws",
    "Odogaron Sinew",
    "Odogaron Hardfang",
    "Odogaron Scale",
    "Zinogre Electrofur",
    "Zinogre Deathly Shocker",
    "Zinogre Cortex",
    "Rathalos Carapace",
    "Rathalos Wings",
    "Rathalos Tail",
    "Kirin Thunderhorn",
    "Kirin Hide",
    "Kirin Mane",
    "Ancient Bone",
    "Kestodon Shell",
    "Bullfango Head",
    "Large Barrel",
    "Gunpowder",
    "Iron Ore",
    "Odogaron Shard",
    "Odogaron Mantle",
    "Zinogre Hardhorn",
    "Zinogre Skymerald",
    "Rathalos Ruby",
    "Rathalos Plate",
    "Kirin Azure Horn",
    "Large Elder Dragon Gem",
    "Wyvern Gem",
    "Warped Bone",
    "Sinister Cloth",
    "Devils Blight",
    "Palico Voucher",
    "Poogie Voucher",
    "Prismatic Pigment"
  ];

  let img = new Image();
  let imgLoaded = false;
  let roi = null;
  let manualMode = false;
  let clickPts = [];
  const cctx = ocrCanvas.getContext("2d", { willReadFrequently: true });
  let displayScale = 1;

  function setStatus(msg) { statusEl.textContent = msg; }

  function drawPreview() {
    if (!imgLoaded) return;

    const maxW = Math.min(window.innerWidth - 40, 1400);
    const scale = Math.min(1, maxW / img.naturalWidth);
    displayScale = scale;

    ocrCanvas.width = Math.floor(img.naturalWidth * scale);
    ocrCanvas.height = Math.floor(img.naturalHeight * scale);

    cctx.clearRect(0, 0, ocrCanvas.width, ocrCanvas.height);
    cctx.drawImage(img, 0, 0, ocrCanvas.width, ocrCanvas.height);

    if (roi) {
      const rx = roi.x * displayScale;
      const ry = roi.y * displayScale;
      const rw = roi.w * displayScale;
      const rh = roi.h * displayScale;
      cctx.save();
      cctx.strokeStyle = "rgba(0,255,160,0.95)";
      cctx.lineWidth = 3;
      cctx.strokeRect(rx, ry, rw, rh);
      cctx.fillStyle = "rgba(0,255,160,0.15)";
      cctx.fillRect(rx, ry, rw, rh);
      cctx.restore();
    }
  }

  function cleanNumber(text) {
    const t = (text || "").replace(/[^\d]/g, "");
    return t ? (parseInt(t, 10) || 0) : 0;
  }

  function preprocessDigitPatch(imageData, scaleUp = 3) {
    const { width, height, data } = imageData;
    const gray = new Uint8ClampedArray(width * height);

    for (let i = 0, p = 0; i < data.length; i += 4, p++) allowing: {
      const r = data[i], g = data[i + 1], b = data[i + 2];
      gray[p] = (r * 0.299 + g * 0.587 + b * 0.114) | 0;
    }

    let sum = 0;
    for (let i = 0; i < gray.length; i++) sum += gray[i];
    const mean = sum / gray.length;

    const bin = new Uint8ClampedArray(width * height);
    for (let i = 0; i < gray.length; i++) {
      bin[i] = gray[i] > (mean + 12) ? 255 : 0;
    }

    const outW = width * scaleUp;
    const outH = height * scaleUp;
    const out = new ImageData(outW, outH);

    for (let y = 0; y < outH; y++) {
      const oy = Math.floor(y / scaleUp);
      for (let x = 0; x < outW; x++) {
        const ox = Math.floor(x / scaleUp);
        const v = bin[oy * width + ox];
        const idx = (y * outW + x) * 4;
        out.data[idx] = v;
        out.data[idx + 1] = v;
        out.data[idx + 2] = v;
        out.data[idx + 3] = 255;
      }
    }
    return out;
  }

  async function autoFindRoi() {
    setStatus("Auto ROI… (OCR bottom half)");

    const W = ocrCanvas.width, H = ocrCanvas.height;
    const cropY = Math.floor(H * 0.55);
    const cropH = H - cropY;

    const imgData = cctx.getImageData(0, cropY, W, cropH);

    const tmp = document.createElement("canvas");
    tmp.width = imgData.width;
    tmp.height = imgData.height;
    tmp.getContext("2d").putImageData(imgData, 0, 0);

    const down = 0.55;
    const scaled = document.createElement("canvas");
    scaled.width = Math.floor(tmp.width * down);
    scaled.height = Math.floor(tmp.height * down);
    scaled.getContext("2d").drawImage(tmp, 0, 0, scaled.width, scaled.height);

    const worker = await Tesseract.createWorker("eng");
    await worker.setParameters({
      tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz "
    });
    const { data } = await worker.recognize(scaled);
    await worker.terminate();

    const words = data.words || [];
    let hit = null;
    for (const w of words) {
      const txt = (w.text || "").toUpperCase();
      if (txt.includes("MATERIAL")) { hit = w; break; }
    }
    if (!hit) {
      for (const w of words) {
        const txt = (w.text || "").toUpperCase();
        if (txt.includes("MY")) { hit = w; break; }
      }
    }
    if (!hit) {
      setStatus("Auto ROI failed. Use Manual ROI.");
      return null;
    }

    const sx = hit.bbox.x0 / down;
    const sy = hit.bbox.y0 / down;
    const ex = hit.bbox.x1 / down;
    const ey = hit.bbox.y1 / down;

    const box = { x: sx, y: sy + cropY, w: (ex - sx), h: (ey - sy) };

    const padX = Math.floor(W * 0.02);
    const top = Math.min(H - 10, Math.floor(box.y + box.h * 1.1));
    const height = Math.min(Math.floor(H * 0.16), H - top);

    const candidate = { x: padX, y: top, w: W - padX * 2, h: height };

    return {
      x: Math.round(candidate.x / displayScale),
      y: Math.round(candidate.y / displayScale),
      w: Math.round(candidate.w / displayScale),
      h: Math.round(candidate.h / displayScale),
    };
  }

  async function runOcrAndFill() {
    if (!roi) {
      setStatus("No ROI. Click Auto ROI or Manual ROI.");
      return;
    }
    setStatus("OCR digits…");

    const full = document.createElement("canvas");
    full.width = img.naturalWidth;
    full.height = img.naturalHeight;
    full.getContext("2d").drawImage(img, 0, 0);

    const bar = document.createElement("canvas");
    bar.width = roi.w;
    bar.height = roi.h;
    bar.getContext("2d").drawImage(full, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

    const slotW = roi.w / TOTAL_SLOTS;

    // digit patch in each slot (tune if needed)
    const digitRel = { x: 0.58, y: 0.45, w: 0.40, h: 0.52 };

    const worker = await Tesseract.createWorker("eng");
    await worker.setParameters({
      tessedit_char_whitelist: "0123456789",
      tessedit_pageseg_mode: "7"
    });

    const nums = [];
    for (let i = 0; i < TOTAL_SLOTS; i++) {
      const x0 = Math.floor(i * slotW);
      const x1 = Math.floor((i + 1) * slotW);
      const w = Math.max(2, x1 - x0);

      const dx = Math.floor(x0 + w * digitRel.x);
      const dy = Math.floor(roi.h * digitRel.y);
      const dw = Math.max(2, Math.floor(w * digitRel.w));
      const dh = Math.max(2, Math.floor(roi.h * digitRel.h));

      const patchCv = document.createElement("canvas");
      patchCv.width = dw;
      patchCv.height = dh;
      patchCv.getContext("2d").drawImage(bar, dx, dy, dw, dh, 0, 0, dw, dh);

      const patchData = patchCv.getContext("2d").getImageData(0, 0, dw, dh);
      const pre = preprocessDigitPatch(patchData, 3);

      const o = document.createElement("canvas");
      o.width = pre.width;
      o.height = pre.height;
      o.getContext("2d").putImageData(pre, 0, 0);

      const { data } = await worker.recognize(o);
      nums.push(cleanNumber(data.text));

      setStatus(`OCR ${i + 1}/${TOTAL_SLOTS}`);
    }

    await worker.terminate();

    // Write inventory
    for (let i = 0; i < TOTAL_SLOTS; i++) {
      const key = MATERIAL_ORDER_EN_FIXED[i];
      INVENTORY[key] = nums[i] ?? 0;
    }

    // refresh inventory table
    const order = CURRENT_MATERIAL_ORDER.length ? CURRENT_MATERIAL_ORDER : MATERIAL_ORDER_EN_FIXED;
    renderInventory(order);

    setStatus("OCR done ✅ Inventory filled.");
  }

  shotFile.addEventListener("change", () => {
    const f = shotFile.files?.[0];
    if (!f) return;

    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = () => {
      imgLoaded = true;
      roi = null;
      manualMode = false;
      clickPts = [];
      drawPreview();
      setStatus("Screenshot loaded ✅ Click Auto ROI / Manual ROI.");
    };
    img.src = url;
  });

  autoRoiBtn.addEventListener("click", async () => {
    if (!imgLoaded) return;
    roi = await autoFindRoi();
    if (roi) {
      drawPreview();
      setStatus("Auto ROI ok ✅");
    }
  });

  manualRoiBtn.addEventListener("click", () => {
    if (!imgLoaded) return;
    manualMode = true;
    clickPts = [];
    roi = null;
    drawPreview();
    setStatus("Manual ROI: click TOP-LEFT then BOTTOM-RIGHT.");
  });

  ocrCanvas.addEventListener("click", (e) => {
    if (!manualMode) return;

    const rect = ocrCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    clickPts.push({ x, y });

    if (clickPts.length === 2) {
      manualMode = false;
      const p0 = clickPts[0], p1 = clickPts[1];
      const x0 = Math.min(p0.x, p1.x);
      const y0 = Math.min(p0.y, p1.y);
      const x1 = apparentlyBreak: Math.max(p0.x, p1.x);
      const y1 = Math.max(p0.y, p1.y);

      roi = {
        x: Math.round(x0 / displayScale),
        y: Math.round(y0 / displayScale),
        w: Math.round((x1 - x0) / displayScale),
        h: Math.round((y1 - y0) / displayScale),
      };
      drawPreview();
      setStatus("Manual ROI set ✅ Click OCR → Fill.");
    }
  });

  ocrBtn.addEventListener("click", async () => {
    if (!imgLoaded) return;
    await runOcrAndFill();
  });

  window.addEventListener("resize", () => drawPreview());
}

///////////////////////////////
// 14) Init
///////////////////////////////
function init() {
  // tree change delegation
  qs("tree").addEventListener("change", (e) => {
    const el = e.target;
    if (!(el instanceof HTMLInputElement)) return;
    if (el.type !== "checkbox") return;

    const themeDiv = el.closest(".theme");
    if (!themeDiv) return;

    if (el.dataset.role === "theme") {
      setThemeState(themeDiv, el.checked);
      updateThemeCheckbox(themeDiv);
      return;
    }
    if (el.dataset.role === "part") {
      updateThemeCheckbox(themeDiv);
      return;
    }
  });

  qs("lang").addEventListener("change", async (e) => {
    LANG = e.target.value;
    await reloadAll();
  });

  qs("mode").addEventListener("change", (e) => {
    MODE = e.target.value;
  });

  qs("computeBtn").addEventListener("click", () => compute());

  qs("copyBtn").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(qs("output").textContent);
      qs("status").textContent = (LANG === "zh") ? "已复制" : "Copied";
    } catch {
      qs("status").textContent = (LANG === "zh") ? "复制失败" : "Copy failed";
    }
  });

  // OCR UI init (safe even if missing)
  initOcrUI();

  reloadAll();
}

document.addEventListener("DOMContentLoaded", init);
